#!/bin/bash                                       # shebang followed by path of interpreter to use to run this script; use -x option at the end to enable code tracing

# variables
variable="value"                                  # notice there is no space around the equality symbol; variable will always be a string regardless of the data type being assigned
echo $variable                                    # $variable expands to "value"
echo "$variable"                                  # same as above but more defensive to use quotes around variable
echo "$variable$variable"                         # concatenation; expands to "valuevalue"

declare -r CONSTANT="value"                       # declaring a constant; rarely used convention

echo "$variable_2"                                # expand `variable_2` and echo
echo "${variable}_2"                              # expand `variable`, concatenate `_2` to it and echo

# reading keyboard input
read x                                            # read keyboard input and assign to variable `x`
read                                              # read input and assign to shell variable `REPLY`
read x1 x2 x3                                     # read inputs separated by space and assign to three variables; if less inputs than variables -> remaining variables are ""; if more inputs than variables than last variable has all the remaining inputs.

# exit command
exit [integer]                                    # every command returns an exit status; 0 indicates success; 1-255 indicate different types of failures; uses exit status of last command if no integer is used

# functions
function function_name {                          # define a function; alternatively, use `function_name () {`
    local variable                                # avoid conflicts with global `variable`
    variable=$1                                   # set variable to the first argument passed to the function
    command
    command
    .
    .
    .
    command
    return [int]                                  # optional statement; int value represents exit status of function
}

function_name "$var1" "$var2" ...                 # call function with multiple arguments

# conditional statements
## if statement syntax
if commands; then
   commands
[elif commands; then
     commands]
[else 
     commands]
fi

## testing commands/expressions: refer chapter 27, page 408 of TLCL for details on file tests
if [ expression ]; then
    commands
fi

[ expression ]                                    # returns true (1) or false (0); need to escape special characters such as <, >, (, )
[ expression && expression ]                      # AND test; `&&` and `-a` are equivalent
[ expression || expression ]                      # OR test; `||` and `-o` are equivalent
[ ! (expression) ]                                # NOT test

[ "$string" ]                                     # true is string is not null
[ -n "$string" ]                                  # true if length of string is greather than zero
[ -z "$string" ]                                  # true if length of string is zero
[ "$string1" == "$string2" ]
[ "$string1" != "$string2" ]
[ "$string1" > "$string2" ]                       # true if $string1 sorts after $string2
[ "$string1" < "$string2" ]

[ $integer1 -eq $integer2 ]                       # do not use quotes around variables for integer tests
[ $integer1 -ne $integer2 ]
[ $integer1 -le $integer2 ]
[ $integer1 -lt $integer2 ]
[ $integer1 -ge $integer2 ]
[ $integer1 -gt $integer2 ]

[ "$file1" -f "$file2" ]                          # returns true if both files have same inode number on disk
[ -w "$file" ]                                    # returns true if file is writable

[[ expression ]]                                  # same as [ expression ] but also supports regex pattern and pathname expansion matching; no need to escape special characters such as <, >, (, )
[[ "$string1" =~ ^[0-9]+$ ]]
[[ "$file" == foo.* ]]

(( expression ))                                  # used only for interger tests; does not require $ and quotes around variable name; no need to escape special characters such as <, >, (, )
(( VALUE == 0 ))
(( ((VALUE % 2)) == 0 ))

## case statement
case variable in
    pattern [| pattern]...) commands ;;           # use `;;&` to continue test since `;;` ends execution of case statement			   
esac
			    
# loops
while condition; do
      commands
      continue
      break
done

while read x y; do
      commands
done < file.txt                                   # file contains two strings separated by space in each line; loop continues until all lines are read

cat file.txt > while read x y; do                 # same as above but with piping
    commands
done

until condition; do
      commands
done

# here command
command << _EOF_                                  # command takes text as input; _EOF_ is a token, any token could be used; use <<- to ignore leading tabs used for better readability
text
_EOF_
